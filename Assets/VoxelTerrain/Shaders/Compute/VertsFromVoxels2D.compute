// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

struct Voxel {
	int x;
	int y;
	int height;
    float3 normalNorth;
    float3 normalSouth;
    float3 normalEast;
    float3 normalWest;
};

// Chunk data
float voxelSize;
int chunkWidth;

RWStructuredBuffer<Voxel> voxels;

// Mesh data
RWStructuredBuffer<float3> verts;
RWStructuredBuffer<int> tris;
RWStructuredBuffer<float3> normals;
RWStructuredBuffer<float2> uvs;

void SetVoxelVerts(uint3 id, uint vertStart) {
	uint vid = id.x + (id.y * chunkWidth);

    float3 v0 = float3(float(voxels[vid].x) * voxelSize, voxels[vid].height, float(voxels[vid].y) * voxelSize);
    float3 v1 = float3(float(voxels[vid].x) * voxelSize, voxels[vid].height, (float(voxels[vid].y) + 1) * voxelSize);
    float3 v2 = float3((float(voxels[vid].x) + 1) * voxelSize, voxels[vid].height, (float(voxels[vid].y) + 1) * voxelSize);
    float3 v3 = float3((float(voxels[vid].x) + 1) * voxelSize, voxels[vid].height, float(voxels[vid].y) * voxelSize);
	float3 v4;
	if (id.y == 0) {
        v4 = float3(float(voxels[vid].x) * voxelSize, -10, float(voxels[vid].y) * voxelSize);
    }
    else
    {
        v4 = float3(float(voxels[vid].x) * voxelSize, float(voxels[vid - chunkWidth].height), float(voxels[vid].y) * voxelSize);
    }

	float3 v7;
	if (id.y == 0) {
        v7 = float3((voxels[vid].x + 1) * voxelSize, -10, voxels[vid].y * voxelSize);
    }
	else {
        v7 = float3((voxels[vid].x + 1) * voxelSize, float(voxels[vid - chunkWidth].height), voxels[vid].y * voxelSize);
    }

	float3 v8;
	if (id.x == 0) {
        v8 = float3(voxels[vid].x * voxelSize, -10, float(voxels[vid].y + 1) * voxelSize);

    }
	else {
        v8 = float3(voxels[vid].x * voxelSize, float(voxels[vid - 1].height), float(voxels[vid].y + 1) * voxelSize);
    }

	float3 v11;
	if (id.x == 0) {
        v11 = float3(voxels[vid].x * voxelSize, -10, voxels[vid].y * voxelSize);
    }
	else {
        v11 = float3(voxels[vid].x * voxelSize, float(voxels[vid - 1].height), voxels[vid].y * voxelSize);
    }

	// Vert order
	// v0, v1, v2, v3, v4, v0, v3, v7, v4, v9, v1, v0
	
    // Top
	verts[vertStart] = v0;
    normals[vertStart] = normalize(lerp(voxels[vid].normalWest, voxels[vid].normalSouth, float3(0.5, 0.5, 0.5)));
    uvs[vertStart] = float2(0, 0);
	
	verts[vertStart + 1] = v1;
    normals[vertStart + 1] = normalize(lerp(voxels[vid].normalWest, voxels[vid].normalNorth, float3(0.5, 0.5, 0.5)));
    uvs[vertStart + 1] = float2(0, 1);
	
	verts[vertStart + 2] = v2;
    normals[vertStart + 2] = normalize(lerp(voxels[vid].normalEast, voxels[vid].normalNorth, float3(0.5, 0.5, 0.5)));
    uvs[vertStart + 2] = float2(1, 1);
	
	verts[vertStart + 3] = v3;
    normals[vertStart + 3] = normalize(lerp(voxels[vid].normalEast, voxels[vid].normalSouth, float3(0.5, 0.5, 0.5)));
    uvs[vertStart + 3] = float2(1, 0);
	
    // Front
	verts[vertStart + 4] = v4;
	verts[vertStart + 5] = v0;
	verts[vertStart + 6] = v3;
	verts[vertStart + 7] = v7;
    
    uvs[vertStart + 4] = float2(0, 0);
    uvs[vertStart + 5] = float2(0, abs(verts[vertStart + 5].y - verts[vertStart + 4].y) / voxelSize);
    uvs[vertStart + 6] = float2(1, abs(verts[vertStart + 5].y - verts[vertStart + 4].y) / voxelSize);
    uvs[vertStart + 7] = float2(1, 0);
    
    if (id.y == 0)
    {
        normals[vertStart + 4] = voxels[vid].normalSouth;
        normals[vertStart + 5] = normalize(lerp(voxels[vid].normalWest, voxels[vid].normalSouth, float3(0.5, 0.5, 0.5)));
        normals[vertStart + 6] = normalize(lerp(voxels[vid].normalEast, voxels[vid].normalSouth, float3(0.5, 0.5, 0.5)));
        normals[vertStart + 7] = voxels[vid].normalSouth;

    }
    else
    {
        normals[vertStart + 4] = normalize(lerp(voxels[vid-chunkWidth].normalWest, voxels[vid].normalSouth, float3(0.5, 0.5, 0.5)));	
        normals[vertStart + 5] = normalize(lerp(voxels[vid].normalWest, voxels[vid].normalSouth, float3(0.5, 0.5, 0.5)));	
        normals[vertStart + 6] = normalize(lerp(voxels[vid].normalEast, voxels[vid].normalSouth, float3(0.5, 0.5, 0.5)));	
        normals[vertStart + 7] = normalize(lerp(voxels[vid-chunkWidth].normalEast, voxels[vid].normalSouth, float3(0.5, 0.5, 0.5)));        
    }
    
	
    // Left
	verts[vertStart + 8] = v8;
	verts[vertStart + 9] = v1;
	verts[vertStart + 10] = v0;
	verts[vertStart + 11] = v11;
    
    uvs[vertStart + 8] = float2(0, 0);
    uvs[vertStart + 9] = float2(0, abs(verts[vertStart + 9].y - verts[vertStart + 8].y) / voxelSize);
    uvs[vertStart + 10] = float2(1, abs(verts[vertStart + 9].y - verts[vertStart + 8].y) / voxelSize);
    uvs[vertStart + 11] = float2(1, 0);
    
    if (id.x == 0)
    {
        normals[vertStart + 8] = voxels[vid].normalWest;	
        normals[vertStart + 9] = normalize(lerp(voxels[vid].normalWest, voxels[vid].normalNorth, float3(0.5, 0.5, 0.5)));	
        normals[vertStart + 10] = normalize(lerp(voxels[vid].normalWest, voxels[vid].normalSouth, float3(0.5, 0.5, 0.5)));	
        normals[vertStart + 11] = voxels[vid].normalWest;
    }
    else
    {
        normals[vertStart + 8] = normalize(lerp(voxels[vid].normalWest, voxels[vid-1].normalNorth, float3(0.5, 0.5, 0.5)));
        normals[vertStart + 9] = normalize(lerp(voxels[vid].normalWest, voxels[vid].normalNorth, float3(0.5, 0.5, 0.5)));
        normals[vertStart + 10] = normalize(lerp(voxels[vid].normalWest, voxels[vid].normalSouth, float3(0.5, 0.5, 0.5)));	
        normals[vertStart + 11] = normalize(lerp(voxels[vid].normalWest, voxels[vid-1].normalSouth, float3(0.5, 0.5, 0.5)));
    }
	
    uint vertEnd = vertStart + 11;
	
    if (id.x == chunkWidth - 1)
    {
		//v12
        verts[vertEnd + 1] = float3(float(voxels[vid].x + 1) * voxelSize, -10, voxels[vid].y * voxelSize);
        normals[vertEnd + 1] = normalize(lerp(voxels[vid].normalEast, voxels[vid].normalSouth, float3(0.5, 0.5, 0.5)));
        uvs[vertEnd + 1] = float2(0, 0);
		
		//v13
        verts[vertEnd + 2] = v3;
        normals[vertEnd + 2] = normalize(lerp(voxels[vid].normalEast, voxels[vid].normalSouth, float3(0.5, 0.5, 0.5)));
        uvs[vertEnd + 2] = float2(0, abs(verts[vertEnd + 2].y - verts[vertEnd + 1].y) / voxelSize);
		
		//v14
        verts[vertEnd + 3] = v2;
        normals[vertEnd + 3] = normalize(lerp(voxels[vid].normalEast, voxels[vid].normalNorth, float3(0.5, 0.5, 0.5)));
        uvs[vertEnd + 3] = float2(1, abs(verts[vertEnd + 2].y - verts[vertEnd + 1].y) / voxelSize);

		//v15
        verts[vertEnd + 4] = float3(float(voxels[vid].x + 1) * voxelSize, -10, float(voxels[vid].y + 1) * voxelSize);
        normals[vertEnd + 4] = normalize(lerp(voxels[vid].normalEast, voxels[vid].normalNorth, float3(0.5, 0.5, 0.5)));
        uvs[vertEnd + 4] = float2(1, 0);
        
        vertEnd = vertEnd + 4;
    }
	
    if (id.y == chunkWidth - 1)
    {
		//v16
        verts[vertEnd + 1] = float3(float(voxels[vid].x + 1) * voxelSize, -10, float(voxels[vid].y + 1) * voxelSize);
        normals[vertEnd + 1] = normalize(lerp(voxels[vid].normalEast, voxels[vid].normalNorth, float3(0.5, 0.5, 0.5)));
        uvs[vertEnd + 1] = float2(0, 0);
		
		//v17
        verts[vertEnd + 2] = v2;
        normals[vertEnd + 2] = normalize(lerp(voxels[vid].normalEast, voxels[vid].normalNorth, float3(0.5, 0.5, 0.5)));
        uvs[vertEnd + 2] = float2(0, abs(verts[vertEnd + 2].y - verts[vertEnd + 1].y) / voxelSize);
		
		//v18
        verts[vertEnd + 3] = v1;
        normals[vertEnd + 3] = normalize(lerp(voxels[vid].normalWest, voxels[vid].normalNorth, float3(0.5, 0.5, 0.5)));
        uvs[vertEnd + 3] = float2(1, abs(verts[vertEnd + 2].y - verts[vertEnd + 1].y) / voxelSize);
		
		//v19
        verts[vertEnd + 4] = float3(voxels[vid].x * voxelSize, -10, float(voxels[vid].y + 1) * voxelSize);
        normals[vertEnd + 4] = normalize(lerp(voxels[vid].normalWest, voxels[vid].normalNorth, float3(0.5, 0.5, 0.5)));
        uvs[vertEnd + 4] = float2(1, 0);
        
        vertEnd = vertEnd + 4;
    }
}

void SetTris(uint vertStart, uint triStart, uint3 id) {
	tris[triStart] = vertStart;
	tris[triStart + 1] = vertStart + 1;
	tris[triStart + 2] = vertStart + 2;

	tris[triStart + 3] = vertStart;
	tris[triStart + 4] = vertStart + 2;
	tris[triStart + 5] = vertStart + 3;

	tris[triStart + 6] = vertStart + 4;
	tris[triStart + 7] = vertStart + 5;
	tris[triStart + 8] = vertStart + 7;

	tris[triStart + 9] = vertStart + 5;
	tris[triStart + 10] = vertStart + 6;
	tris[triStart + 11] = vertStart + 7;

	tris[triStart + 12] = vertStart + 8;
	tris[triStart + 13] = vertStart + 9;
	tris[triStart + 14] = vertStart + 11;

	tris[triStart + 15] = vertStart + 9;
	tris[triStart + 16] = vertStart + 10;
	tris[triStart + 17] = vertStart + 11;
	
    uint triEnd = triStart + 17;
    uint vertEnd = vertStart + 11;
	
    if (id.x == chunkWidth - 1)
    {
		// {12, 13, 14}
        tris[triEnd + 1] = vertEnd + 1; // t18, v12
        tris[triEnd + 2] = vertEnd + 2; // t19, v13
        tris[triEnd + 3] = vertEnd + 3; // t20, v14
		
		// {12, 14, 15}
        tris[triEnd + 4] = vertEnd + 1; // t21, v12
        tris[triEnd + 5] = vertEnd + 3; // t22, v14
        tris[triEnd + 6] = vertEnd + 4; // t23, v15
		
        triEnd = triEnd + 6;
        vertEnd = vertEnd + 4;
    }
	
    if (id.y == chunkWidth - 1)
    {
		// {16, 17, 18}
        tris[triEnd + 1] = vertEnd + 1; // t24, v16
        tris[triEnd + 2] = vertEnd + 2; // t25, v17
        tris[triEnd + 3] = vertEnd + 3; // t26, v18
		
		// {16, 18, 19}
        tris[triEnd + 4] = vertEnd + 1; // t27, v16
        tris[triEnd + 5] = vertEnd + 3; // t28, v18
        tris[triEnd + 6] = vertEnd + 4; // t29, v19
		
        triEnd = triEnd + 6;
        vertEnd = vertEnd + 4;
    }
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
	uint vid = id.x + (id.y * chunkWidth);
    uint vertStart = vid * 12 + (id.y * 4);
    uint triStart = vid * 18 + (id.y * 6);
	 /*
    if (id.x == 0)
    {
        vertStart += 
        triStart += id.y * 6;
    }*/
    
	if (id.y == chunkWidth - 1)
    {
        vertStart += id.x * 4;
        triStart += id.x * 6;
    }
	

	SetVoxelVerts(id, vertStart);
	SetTris(vertStart, triStart, id);
}