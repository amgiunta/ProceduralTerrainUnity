// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

struct Voxel {
    float3 position;
    float3 normal;
};

// Chunk data
float voxelSize;
uint chunkWidth;

RWStructuredBuffer<Voxel> voxels;
RWStructuredBuffer<Voxel> rightEdge;
RWStructuredBuffer<Voxel> topEdge;

// Mesh data
RWStructuredBuffer<float3> verts;
RWStructuredBuffer<int> tris;
RWStructuredBuffer<float3> normals;
RWStructuredBuffer<float2> uv0s;
RWStructuredBuffer<float2> uv1s;

void SetDataForVoxel(uint3 id)
{
    int index = (id.y * chunkWidth + id.x) * 4;
    int triIndex = (id.y * chunkWidth + id.x) * 6;
    Voxel voxel = voxels[id.y * chunkWidth + id.x];
    Voxel north;
    Voxel east;
    Voxel northeast;
    
    if (id.y == chunkWidth - 1)
    {
        north = topEdge[id.x];        
    }
    else
    {
        north = voxels[(id.y + 1) * chunkWidth + id.x];        
    }
    
    if (id.x == chunkWidth -1)
    {
        east = rightEdge[id.y];        
    }
    else
    {
        east = voxels[id.y * chunkWidth + id.x + 1];
    }
    
    if (id.x == chunkWidth - 1 && id.y == chunkWidth - 1)
    {
        northeast = topEdge[chunkWidth];
    }

    else if (id.x == chunkWidth - 1)
    {
        northeast = rightEdge[id.y + 1];

    }
    else if (id.y == chunkWidth - 1)
    {
        northeast = topEdge[id.x + 1];
    }
    else
    {
        northeast = voxels[(id.y + 1) * chunkWidth + id.x + 1];
    }
    
    for (int i = 0; i < 4; i++)
    {
        float3 position;
        float3 normal;
        float2 uv0;
        float2 uv1;
        if (i == 0)
        {
            normal = voxel.normal;
            position = float3(
                float(voxel.position.x) - 0.5,
                float(voxel.position.y),
                float(voxel.position.z) - 0.5
            );
            uv0 = float2(
                0,
                0
            );
        }
        else if (i == 1)
        {
            normal = north.normal;
            position = float3(
                float(north.position.x) - 0.5,
                float(north.position.y),
                float(north.position.z) - 0.5
            );
            uv0 = float2(
                0,
                1
            );
        }
        else if (i == 2)
        {
            normal = northeast.normal;
            position = float3(
                float(northeast.position.x) - 0.5,
                float(northeast.position.y),
                float(northeast.position.z) - 0.5
            );
            uv0 = float2(
                1,
                1
            );
        }
        else
        {
            normal = east.normal;
            position = float3(
                float(east.position.x) - 0.5,
                float(east.position.y),
                float(east.position.z) - 0.5
            );
            uv0 = float2(
                0,
                1
            );
        }
        
        uv1 = float2(
            position.x / chunkWidth,
            position.z / chunkWidth
        );
        
        verts[index + i] = position * voxelSize;
        normals[index + i] = normal;
        uv0s[index + i] = uv0;
        uv1s[index + i] = uv1;
    }

    tris[triIndex] = index;
    tris[triIndex + 1] = index + 1;
    tris[triIndex + 2] = index + 3;
    tris[triIndex + 3] = index + 1;
    tris[triIndex + 4] = index + 2;
    tris[triIndex + 5] = index + 3;
}

[numthreads(1,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    SetDataForVoxel(id);
}